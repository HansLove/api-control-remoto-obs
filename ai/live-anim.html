```html
<!doctype html>
<html lang="en">
<head>
  <!-- OBS: Fuente Navegador. ?broadcast=1 = cámara + envía manos; activa "Usar fondo transparente" en propiedades de la fuente. ?obs=1 oculta HUD, ?transparent=0 quita transparencia. -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cyberpunk Hand-Driven Particle HUD · OBS</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --cyan:#00ffff;
      --bg:transparent; /* default transparent for OBS overlay */
    }
    html,body{
      margin:0; height:100%; background:var(--bg); overflow:hidden;
      font-family: Orbitron, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    #wrap{
      position:fixed; inset:0;
    }
    canvas#gl{
      position:absolute; inset:0;
      display:block;
    }

    /* Cyberpunk overlays: moving grid + scanlines + vignette */
    .overlay{
      pointer-events:none;
      position:absolute; inset:0;
      mix-blend-mode: screen;
      opacity:0.55;
    }
    .grid{
      background:
        linear-gradient(rgba(0,255,255,0.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,255,255,0.08) 1px, transparent 1px);
      background-size: 48px 48px, 48px 48px;
      filter: blur(0.2px);
      transform: translate3d(0,0,0);
      animation: gridMove 7.5s linear infinite;
      opacity:0.35;
    }
    @keyframes gridMove{
      0%{ background-position: 0 0, 0 0; }
      100%{ background-position: 0 240px, 240px 0; }
    }
    .scanlines{
      background: repeating-linear-gradient(
        to bottom,
        rgba(0,255,255,0.05) 0px,
        rgba(0,255,255,0.02) 2px,
        rgba(0,0,0,0.0) 4px
      );
      animation: scan 1.15s linear infinite;
      opacity:0.38;
    }
    @keyframes scan{
      0%{ transform: translateY(0px); }
      100%{ transform: translateY(18px); }
    }
    .vignette{
      background: radial-gradient(circle at 50% 50%,
        rgba(0,0,0,0.00) 0%,
        rgba(0,0,0,0.20) 55%,
        rgba(0,0,0,0.65) 100%
      );
      mix-blend-mode: multiply;
      opacity:1;
    }

    /* HUD */
    #hud{
      position:absolute; inset:0; pointer-events:none;
      color: var(--cyan);
      text-shadow:
        0 0 10px rgba(0,255,255,0.65),
        0 0 22px rgba(0,255,255,0.25);
      font-size: 12px;
      letter-spacing: 0.12em;
      opacity:0.92;
    }
    .corner{
      position:absolute; padding:12px 14px;
      background: linear-gradient(90deg, rgba(0,255,255,0.07), rgba(0,0,0,0));
      border: 1px solid rgba(0,255,255,0.10);
      border-radius: 10px;
      backdrop-filter: blur(2px);
    }
    #tl{ top:12px; left:12px; }
    #tr{ top:12px; right:12px; text-align:right; }
    #bl{ bottom:12px; left:12px; }
    #br{ bottom:12px; right:12px; text-align:right; }

    .label{ opacity:0.75; font-weight:600; }
    .value{ font-weight:800; }
    .warn{ color:#ff00ff; text-shadow:0 0 12px rgba(255,0,255,0.6); }
    .ok{ color:#00ff88; text-shadow:0 0 12px rgba(0,255,136,0.55); }

    /* Camera preview hidden (still used by MediaPipe) */
    video#cam{
      position:absolute; width:1px; height:1px; opacity:0; pointer-events:none;
    }

    /* Small hint */
    #hint{
      position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
      color: rgba(0,255,255,0.75);
      font-size: 11px;
      letter-spacing: 0.12em;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(0,255,255,0.12);
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(3px);
      text-shadow: 0 0 10px rgba(0,255,255,0.55);
      pointer-events:none;
      user-select:none;
      opacity:0.85;
    }

    /* OBS / Presentación: ocultar HUD para transmisión limpia */
    body.obs-mode #hud,
    body.obs-mode #hint { display: none !important; }
    /* Fondo transparente para overlay en OBS (?transparent=1 o ?broadcast=1) */
    body.transparent,
    body.obs-mode.transparent { background: transparent !important; }
    html.transparent { background: transparent !important; }
  </style>
</head>

<body>
  <div id="wrap">
    <canvas id="gl"></canvas>

    <div class="overlay grid"></div>
    <div class="overlay scanlines"></div>
    <div class="overlay vignette"></div>

    <div id="hud">
      <div id="tl" class="corner">
        <div><span class="label">FPS</span> <span class="value" id="fps">--</span></div>
        <div><span class="label">DT</span> <span class="value" id="dt">--</span> <span class="label">ms</span></div>
      </div>
      <div id="tr" class="corner">
        <div><span class="label">PARTICLES</span> <span class="value" id="pc">12000</span></div>
        <div><span class="label">MODE</span> <span class="value" id="mode">MAIN</span></div>
      </div>
      <div id="bl" class="corner">
        <div><span class="label">LEFT HAND</span> <span class="value" id="lh">--</span></div>
        <div><span class="label">COMMAND</span> <span class="value" id="cmd">--</span></div>
      </div>
      <div id="br" class="corner">
        <div><span class="label">RIGHT HAND</span> <span class="value" id="rh">--</span></div>
        <div><span class="label">NEBULA</span> <span class="value" id="neb">OFF</span></div>
      </div>
    </div>

    <div id="hint">Mano izq: 1–4 dedos = figura 3D (cubo, esfera, toro, cono). Palma abierta = CATCH. Mano der: puño = tocar. Palma abierta = NEBULA. Ambas abiertas = pelota. Paz (2) = siguiente objeto flotante. Tecla C = RECENTER.</div>

    <div id="relay-status" style="display:none; position:absolute; top:14px; left:50%; transform:translateX(-50%); color:#00ff88; font-size:12px; letter-spacing:0.1em; padding:8px 14px; border-radius:999px; border:1px solid rgba(0,255,136,0.4); background:rgba(0,0,0,0.5); pointer-events:none;">Enviando al relé ✓</div>

    <video id="cam" playsinline></video>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    (() => {
      // =========================
      // OBS / Presentación (URL: ?obs=1 ?presentation=1 ?transparent=1)
      // =========================
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('obs') === '1' || urlParams.get('presentation') === '1') {
        document.body.classList.add('obs-mode');
      }
      if (urlParams.get('transparent') === '1') {
        document.body.classList.add('transparent');
        document.documentElement.classList.add('transparent');
      }
      const broadcastHands = urlParams.get('broadcast') === '1';
      // Con broadcast=1 usar fondo transparente por defecto (overlay en OBS). ?transparent=0 lo desactiva.
      if (broadcastHands && urlParams.get('transparent') !== '0') {
        document.body.classList.add('transparent');
        document.documentElement.classList.add('transparent');
      }

      // =========================
      // CONFIG: Mano izquierda 1–4 dedos. Cada slot: shape (figura 3D) o text (texto personalizado).
      // =========================
      const CONFIG = {
        leftSlots: [
          { type: 'shape', shape: 'cube',   color: 0x00FFFF },
          { type: 'shape', shape: 'sphere', color: 0xFFFF00 },
          { type: 'shape', shape: 'torus',  color: 0xFF00FF },
          { type: 'shape', shape: 'cone',   color: 0x00FF88 }
          // Ejemplo con texto: { type: 'text', text: 'Hola', color: 0x00FF88 }
        ]
      };

      // =========================
      // Core Tunables
      // =========================
      const PARTICLE_COUNT = 12000;
      const SHAPE_SCALE = 140; // tamaño base de figuras 3D
      const PARTICLE_SIZE  = 2.4;
      const LERP_RETURN    = 0.16;   // fast return speed
      const REPULSE_STRENGTH = 1.85; // snappy repulsion
      const SCATTER_IMPULSE  = 3.25; // strong scatter on touch (text mode)
      const NEBULA_DEPTH     = 900;  // 3D fill depth
      const RIPPLE_FREQ      = 0.045;
      const RIPPLE_AMP       = 18.0;

      // Colors
      const C_NEON_BLUE    = 0x00FFFF;
      const C_NEON_YELLOW  = 0xFFFF00;
      const C_NEON_PINK    = 0xFF00FF;
      const C_NEON_GREEN   = 0x00FF88;
      const C_BBALL_ORANGE = 0xFF8A00;

      // =========================
      // HUD
      // =========================
      const $fps  = document.getElementById('fps');
      const $dt   = document.getElementById('dt');
      const $pc   = document.getElementById('pc');
      const $mode = document.getElementById('mode');
      const $lh   = document.getElementById('lh');
      const $rh   = document.getElementById('rh');
      const $cmd  = document.getElementById('cmd');
      const $neb  = document.getElementById('neb');

      $pc.textContent = String(PARTICLE_COUNT);

      // =========================
      // Three.js Setup
      // =========================
      const canvas = document.getElementById('gl');
      const useTransparent = document.body.classList.contains('transparent');
      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: false,
        alpha: useTransparent,
        powerPreference: "high-performance"
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, useTransparent ? 0 : 1);
      renderer.autoClear = true;

      const scene = new THREE.Scene();

      // Camera
      const camera = new THREE.PerspectiveCamera(55, 1, 1, 5000);
      camera.position.set(0, 0, 1100);
      camera.lookAt(0,0,0);

      // Resize
      let vw = 1, vh = 1;
      let viewW = 1200, viewH = 700; // world-space plane size
      function resize(){
        vw = window.innerWidth;
        vh = window.innerHeight;
        renderer.setSize(vw, vh, false);
        camera.aspect = vw / vh;
        camera.updateProjectionMatrix();

        // compute visible plane size at z=0
        const dist = camera.position.z;
        const fovRad = camera.fov * Math.PI / 180;
        viewH = 2 * Math.tan(fovRad / 2) * dist;
        viewW = viewH * camera.aspect;
      }
      window.addEventListener('resize', resize, {passive:true});
      resize();

      // =========================
      // Particle Buffers
      // =========================
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const velocities = new Float32Array(PARTICLE_COUNT * 3);
      const targets = new Float32Array(PARTICLE_COUNT * 3);
      const colors = new Float32Array(PARTICLE_COUNT * 3);

      const phase = new Float32Array(PARTICLE_COUNT);
      const seed  = new Float32Array(PARTICLE_COUNT);

      // Initialize particles in a mild nebula
      for (let i=0;i<PARTICLE_COUNT;i++){
        const i3 = i*3;
        const rx = (Math.random()-0.5) * viewW * 1.05;
        const ry = (Math.random()-0.5) * viewH * 1.05;
        const rz = (Math.random()-0.5) * 240;

        positions[i3+0] = rx;
        positions[i3+1] = ry;
        positions[i3+2] = rz;

        velocities[i3+0] = (Math.random()-0.5) * 0.6;
        velocities[i3+1] = (Math.random()-0.5) * 0.6;
        velocities[i3+2] = (Math.random()-0.5) * 0.4;

        targets[i3+0] = rx;
        targets[i3+1] = ry;
        targets[i3+2] = 0;

        colors[i3+0] = 0.0;
        colors[i3+1] = 1.0;
        colors[i3+2] = 1.0;

        phase[i] = Math.random() * Math.PI * 2;
        seed[i]  = Math.random();
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.92,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        depthTest: true
      });

      const points = new THREE.Points(geometry, material);
      scene.add(points);

      // =========================
      // Objetos 3D para mini presentaciones (gestos: paz = siguiente, puño = ocultar)
      // =========================
      const presentationGroup = new THREE.Group();
      scene.add(presentationGroup);

      const wireMat = (color) => new THREE.MeshBasicMaterial({
        color,
        wireframe: true,
        transparent: true,
        opacity: 0.9
      });

      const presGeo = {
        box: new THREE.BoxGeometry(120, 120, 120),
        sphere: new THREE.SphereGeometry(80, 32, 24),
        torus: new THREE.TorusGeometry(70, 28, 16, 48)
      };
      const presMeshes = [
        new THREE.Mesh(presGeo.box, wireMat(C_NEON_BLUE)),
        new THREE.Mesh(presGeo.sphere, wireMat(C_NEON_PINK)),
        new THREE.Mesh(presGeo.torus, wireMat(C_NEON_YELLOW))
      ];
      presMeshes.forEach((m) => {
        m.visible = false;
        m.position.set(0, 0, -200);
        m.rotation.order = 'YXZ';
        presentationGroup.add(m);
      });

      let currentPresIndex = 0;
      let prevRightFingersForPres = -1;

      function updatePresentationObject(visible, index){
        presMeshes.forEach((m, i) => { m.visible = visible && i === index; });
      }

      // =========================
      // Target generation: figuras 3D + texto opcional
      // =========================
      function hexToRgb01(hex){
        const r = ((hex>>16)&255)/255;
        const g = ((hex>>8)&255)/255;
        const b = (hex&255)/255;
        return [r,g,b];
      }

      function buildShapeTargets(shapeName, colorHex){
        const N = PARTICLE_COUNT;
        const s = SHAPE_SCALE;
        const [cr,cg,cb] = hexToRgb01(colorHex);
        const golden = Math.PI * (3 - Math.sqrt(5));

        for (let i = 0; i < N; i++) {
          const i3 = i * 3;
          let x = 0, y = 0, z = 0;

          if (shapeName === 'sphere') {
            const phi = Math.acos(1 - 2 * (i + 0.5) / N);
            const theta = golden * i;
            x = Math.sin(phi) * Math.cos(theta);
            y = Math.cos(phi);
            z = Math.sin(phi) * Math.sin(theta);
          } else if (shapeName === 'cube') {
            const side = (i * 7) % 6;
            const u = ((i * 137) % 1000) / 1000;
            const v = ((i * 421) % 1000) / 1000;
            const a = (u - 0.5) * 2, b = (v - 0.5) * 2;
            if (side === 0) { x = 1; y = a; z = b; }
            else if (side === 1) { x = -1; y = a; z = b; }
            else if (side === 2) { y = 1; x = a; z = b; }
            else if (side === 3) { y = -1; x = a; z = b; }
            else if (side === 4) { z = 1; x = a; y = b; }
            else { z = -1; x = a; y = b; }
          } else if (shapeName === 'torus') {
            const u = (i / N) * Math.PI * 2;
            const v = ((i * 7) % N) / N * Math.PI * 2;
            const R = 1, r = 0.4;
            x = (R + r * Math.cos(v)) * Math.cos(u);
            y = r * Math.sin(v);
            z = (R + r * Math.cos(v)) * Math.sin(u);
          } else if (shapeName === 'cone') {
            const t = i / N;
            const rad = 1 - t * 0.999;
            const angle = (i * 137.5 * Math.PI / 180) + t * 10;
            x = rad * Math.cos(angle);
            y = -1 + 2 * (1 - t);
            z = rad * Math.sin(angle);
          }

          targets[i3+0] = x * s;
          targets[i3+1] = y * s;
          targets[i3+2] = z * s;
          colors[i3+0] = cr;
          colors[i3+1] = cg;
          colors[i3+2] = cb;
        }
        geometry.attributes.color.needsUpdate = true;
      }

      const textCanvas = document.createElement('canvas');
      const textCtx = textCanvas.getContext('2d', {willReadFrequently:true});

      function buildTextTargets(str, colorHex){
        const fontSize = 75;
        const padding = 30;
        textCtx.font = `800 ${fontSize}px Orbitron, monospace`;
        const metrics = textCtx.measureText(str);
        const w = Math.ceil(metrics.width) + padding*2;
        const h = Math.ceil(fontSize*1.35) + padding*2;

        textCanvas.width = w;
        textCanvas.height = h;
        textCtx.clearRect(0,0,w,h);
        textCtx.font = `800 ${fontSize}px Orbitron, monospace`;
        textCtx.textBaseline = 'middle';
        textCtx.textAlign = 'center';
        textCtx.fillStyle = '#FFFFFF';
        textCtx.fillText(str, w/2, h/2);

        const img = textCtx.getImageData(0,0,w,h).data;
        const coords = [];
        const stride = 2;
        for (let y=0; y<h; y+=stride){
          for (let x=0; x<w; x+=stride){
            const idx = (y*w + x) * 4;
            if (img[idx+3] > 40) coords.push(x, y);
          }
        }

        const normW = w, normH = h;
        const scale = Math.min((viewW*0.72)/normW, (viewH*0.32)/normH);
        const [cr,cg,cb] = hexToRgb01(colorHex);
        let count = coords.length / 2;
        if (count === 0) { coords.push(w/2, h/2); count = 1; }

        for (let i=0;i<PARTICLE_COUNT;i++){
          const i3 = i*3;
          const pick = (i * 997) % count;
          const px = coords[pick*2+0], py = coords[pick*2+1];
          targets[i3+0] = (px - normW/2) * scale;
          targets[i3+1] = (normH/2 - py) * scale;
          targets[i3+2] = 0;
          colors[i3+0] = cr; colors[i3+1] = cg; colors[i3+2] = cb;
        }
        geometry.attributes.color.needsUpdate = true;
      }

      function applySlot(slot){
        if (slot.type === 'shape') buildShapeTargets(slot.shape, slot.color);
        else buildTextTargets(slot.text || '?', slot.color);
      }

      function slotLabel(slot){
        if (slot.type === 'shape') return (slot.shape || '').toUpperCase();
        return (slot.text || '?').slice(0, 10);
      }

      // Estado: slot actual (1 dedo = índice 0)
      const defaultSlot = { type: 'shape', shape: 'sphere', color: C_NEON_BLUE };
      let currentSlotIndex = 0;
      let currentSlot = CONFIG.leftSlots[0] || defaultSlot;
      applySlot(currentSlot);

      // =========================
      // Modes & State
      // =========================
      const MODE_MAIN = 0;
      const MODE_NEBULA = 1;
      const MODE_ULT = 2;

      let mode = MODE_MAIN;

      const SMOOTH_LERP = 0.35;

      // =========================
      // Center calibration (hand->world offset)
      // =========================
      let centerOffset = new THREE.Vector3(0, 0, 0);
      let calibrated = false;
      function calibrateCenter(){
        centerOffset.set(-rightIndexSmoothed.x, -rightIndexSmoothed.y, 0);
        calibrated = true;
      }
      let didAutoCalibrate = false;

      // Left hand: command controller
      let leftDetected = false;
      let leftFingers = 0;
      let leftCatch = false;
      let leftPalm = new THREE.Vector3(0,0,0);

      // Right hand: interactor
      let rightDetected = false;
      let rightOpen = false;
      let rightFingers = 0;
      let rightIndex = new THREE.Vector3(0,0,0);
      let rightIndexSmoothed = new THREE.Vector3(0,0,0);
      let rightPrev = new THREE.Vector3(0,0,0);
      let rightVel = new THREE.Vector3(0,0,0);

      // Scatter timers
      let scatterPulse = 0;

      // Nebula: centered radial targets
      function setNebulaTargets(){
        const R = Math.min(viewW, viewH) * 0.52;
        for (let i=0;i<PARTICLE_COUNT;i++){
          const i3 = i*3;
          const a = Math.random() * Math.PI * 2;
          const r = Math.sqrt(Math.random()) * R;
          targets[i3+0] = Math.cos(a) * r;
          targets[i3+1] = Math.sin(a) * r;
          targets[i3+2] = (Math.random()-0.5) * NEBULA_DEPTH;
        }
      }

      // =========================
      // Basketball
      // =========================
      const bball = { radius: 160, rot: 0 };

      function setBasketballTargets(palmWorld){
        const N = PARTICLE_COUNT;
        const golden = Math.PI * (3 - Math.sqrt(5));
        const [or,og,ob] = hexToRgb01(C_BBALL_ORANGE);

        for (let i=0;i<N;i++){
          const i3 = i*3;

          const y = 1 - (i / (N - 1)) * 2;
          const rr = Math.sqrt(Math.max(0, 1 - y*y));
          const theta = golden * i;

          const x = Math.cos(theta) * rr;
          const z = Math.sin(theta) * rr;

          targets[i3+0] = palmWorld.x + x * bball.radius;
          targets[i3+1] = palmWorld.y + y * bball.radius;
          targets[i3+2] = palmWorld.z + z * bball.radius;

          const lat = Math.asin(y);
          const lon = Math.atan2(z, x);

          const band1 = Math.abs(Math.sin(lon * 2.0)) < 0.08 ? 1 : 0;
          const band2 = Math.abs(Math.sin(lat * 3.0)) < 0.08 ? 1 : 0;
          const band3 = Math.abs(Math.sin((lon + lat) * 1.7)) < 0.08 ? 1 : 0;
          const seam = (band1 || band2 || band3);

          if (seam){
            colors[i3+0] = 0.05; colors[i3+1] = 0.05; colors[i3+2] = 0.05;
          } else {
            colors[i3+0] = or; colors[i3+1] = og; colors[i3+2] = ob;
          }
        }
        geometry.attributes.color.needsUpdate = true;
      }

      function rotateBasketballTargets(palmWorld, dt){
        bball.rot += dt * 1.4;
        const s = Math.sin(bball.rot);
        const c = Math.cos(bball.rot);

        for (let i=0;i<PARTICLE_COUNT;i++){
          const i3 = i*3;
          const tx = targets[i3+0] - palmWorld.x;
          const ty = targets[i3+1] - palmWorld.y;
          const tz = targets[i3+2] - palmWorld.z;

          const rx = ( tx * c + tz * s );
          const rz = ( -tx * s + tz * c );

          const sx = Math.sin(bball.rot * 0.65) * 0.08;
          const cc = Math.cos(bball.rot * 0.65);
          const ry = (ty * cc - rz * sx);
          const rzz = (ty * sx + rz * cc);

          targets[i3+0] = palmWorld.x + rx;
          targets[i3+1] = palmWorld.y + ry;
          targets[i3+2] = palmWorld.z + rzz;
        }
      }

      // =========================
      // Hand Utilities (Finger Counting + Mapping)
      // =========================
      function normToWorld(u, v){
        // mirror horizontally + apply calibration offset
        const x = (((1 - u) - 0.5) * viewW) + (calibrated ? centerOffset.x : 0);
        const y = (((0.5 - v) * viewH) + (calibrated ? centerOffset.y : 0));
        return new THREE.Vector3(x,y,0);
      }

      function palmCenter(landmarks){
        const a = landmarks[0], b = landmarks[5], c = landmarks[17];
        const u = (a.x + b.x + c.x) / 3;
        const v = (a.y + b.y + c.y) / 3;
        return normToWorld(u,v);
      }

      function countExtendedFingers(landmarks, handednessLabel){
        let count = 0;
        const tips = [4,8,12,16,20];
        const pips = [3,6,10,14,18];

        const thumbTip = landmarks[tips[0]];
        const thumbIP  = landmarks[pips[0]];
        if (handednessLabel === "Left"){
          if (thumbTip.x < thumbIP.x) count++;
        } else {
          if (thumbTip.x > thumbIP.x) count++;
        }

        for (let i = 1; i < 5; i++){
          const tip = landmarks[tips[i]];
          const pip = landmarks[pips[i]];
          if (tip.y < pip.y) count++;
        }
        return count;
      }

      // =========================
      // MediaPipe Hands
      // =========================
      const video = document.getElementById('cam');

      const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      hands.onResults((results) => {
        leftDetected = false;
        rightDetected = false;
        leftFingers = 0;
        leftCatch = false;
        rightOpen = false;
        rightFingers = 0;

        if (!results.multiHandLandmarks || !results.multiHandedness) return;

        for (let h=0; h<results.multiHandLandmarks.length; h++){
          const lm = results.multiHandLandmarks[h];
          const handed = results.multiHandedness[h] && results.multiHandedness[h].label ? results.multiHandedness[h].label : "Right";

          const fingers = countExtendedFingers(lm, handed);

          if (handed === "Left"){
            leftDetected = true;
            leftFingers = fingers;
            leftCatch = (fingers === 5);
            leftPalm.copy(palmCenter(lm));
          } else {
            rightDetected = true;
            rightFingers = fingers;
            rightOpen = (fingers === 5);
            const idxTip = lm[8];
            const p = normToWorld(idxTip.x, idxTip.y);
            rightIndex.copy(p);
          }
        }

        // Auto-calibrate once when right hand appears
        if (rightDetected && !didAutoCalibrate) {
          rightIndexSmoothed.copy(rightIndex);
          rightPrev.copy(rightIndexSmoothed);
          calibrateCenter();
          didAutoCalibrate = true;
        }

        // Relé OBS: enviar manos (coords normalizadas)
        if (window.wsHands && window.wsHands.readyState === 1 && viewW > 0 && viewH > 0) {
          window.wsHands.send(JSON.stringify({
            left: { d: leftDetected, f: leftFingers, p: [leftPalm.x/viewW, leftPalm.y/viewH, 0] },
            right: { d: rightDetected, f: rightFingers, i: [rightIndex.x/viewW, rightIndex.y/viewH, 0] }
          }));
        }
      });

      if (broadcastHands) {
        const relayUrl = (location.protocol === "https:" ? "wss:" : "ws:") + "//" + (location.hostname || "localhost") + ":8765";
        window.wsHands = new WebSocket(relayUrl);
        window.wsHands.onopen = () => {
          console.log("Hands relay: enviando a", relayUrl);
          const el = document.getElementById("relay-status");
          if (el) { el.style.display = "block"; el.textContent = "Enviando al relé ✓"; }
        };
        window.wsHands.onerror = () => {};
        window.wsHands.onclose = () => {
          const el = document.getElementById("relay-status");
          if (el) { el.style.display = "block"; el.textContent = "Relé desconectado"; el.style.color = "#ff6666"; }
        };
      }

      const cam = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 1280,
        height: 720
      });

      cam.start().catch((e) => console.warn("Camera start failed:", e));

      // Hotkey: C to recenter based on current right hand
      window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'c') {
          calibrateCenter();
          console.log("Recenter calibrated (C)");
        }
      });

      // =========================
      // Left Command: 1–4 fingers -> slot
      // =========================
      function applyLeftCommand(fingers){
        if (fingers < 1 || fingers > 4) return;
        const idx = fingers - 1;
        const slot = CONFIG.leftSlots[idx] || defaultSlot;
        if (!slot) return;
        if (currentSlotIndex === idx) return;
        currentSlotIndex = idx;
        currentSlot = slot;
        applySlot(currentSlot);
      }

      // =========================
      // Physics / Interaction
      // =========================
      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

      function applyPlanarRepulsion(dt){
        const hx = rightIndexSmoothed.x;
        const hy = rightIndexSmoothed.y;

        const touchR = 95;
        const r2 = touchR * touchR;

        let touched = 0;

        for (let i=0;i<PARTICLE_COUNT;i++){
          const i3 = i*3;
          const px = positions[i3+0];
          const py = positions[i3+1];

          const dx = px - hx;
          const dy = py - hy;
          const d2 = dx*dx + dy*dy;

          if (d2 < r2){
            touched++;
            const d = Math.sqrt(d2) + 1e-6;
            const falloff = 1.0 - (d / touchR);
            const fx = (dx / d) * falloff * REPULSE_STRENGTH * 180;
            const fy = (dy / d) * falloff * REPULSE_STRENGTH * 180;
            velocities[i3+0] += fx * dt;
            velocities[i3+1] += fy * dt;
          }
        }

        if (touched > 18) scatterPulse = 1.0;
      }

      function applyScatterImpulse(dt){
        if (scatterPulse <= 0) return;
        scatterPulse = Math.max(0, scatterPulse - dt * 3.2);

        const hx = rightIndexSmoothed.x;
        const hy = rightIndexSmoothed.y;

        const blastR = 170;
        const r2 = blastR * blastR;

        for (let i=0;i<PARTICLE_COUNT;i++){
          const i3 = i*3;
          const px = positions[i3+0];
          const py = positions[i3+1];
          const dx = px - hx;
          const dy = py - hy;
          const d2 = dx*dx + dy*dy;
          if (d2 < r2){
            const d = Math.sqrt(d2) + 1e-6;
            const fall = 1.0 - (d / blastR);
            const impulse = SCATTER_IMPULSE * fall * (0.4 + 0.6*scatterPulse);
            velocities[i3+0] += (dx / d) * impulse * 120;
            velocities[i3+1] += (dy / d) * impulse * 120;
          }
        }
      }

      function applyNebulaRipple(dt, t){
        const speed = clamp(rightVel.length() * 0.018, 0, 1);
        if (speed <= 0.02) return;

        const hx = rightIndexSmoothed.x;
        const hy = rightIndexSmoothed.y;
        const hz = rightIndexSmoothed.z;

        const influenceR = 260;
        const r2 = influenceR * influenceR;

        for (let i=0;i<PARTICLE_COUNT;i++){
          const i3 = i*3;
          const px = positions[i3+0];
          const py = positions[i3+1];
          const pz = positions[i3+2];

          const dx = px - hx;
          const dy = py - hy;
          const dz = pz - hz;

          const d2 = dx*dx + dy*dy + dz*dz;
          if (d2 < r2){
            const d = Math.sqrt(d2) + 1e-6;
            const fall = 1.0 - (d / influenceR);
            const wave = Math.sin((d * RIPPLE_FREQ) - (t * 10.0)) * RIPPLE_AMP * fall * speed;

            const vx = rightVel.x, vy = rightVel.y;
            const vlen = Math.sqrt(vx*vx + vy*vy) + 1e-6;
            const nx = -vy / vlen;
            const ny =  vx / vlen;

            velocities[i3+0] += nx * wave * dt * 12;
            velocities[i3+1] += ny * wave * dt * 12;
            velocities[i3+2] += Math.sin((t + seed[i]*6.0)) * wave * dt * 2.2;
          }
        }
      }

      function applyUltimateBouncingAttraction(dt, t){
        const bounceFreq = 28.0;
        const bounceAmp  = 22.0;
        const attractGain = 2.6;

        for (let i=0;i<PARTICLE_COUNT;i++){
          const i3 = i*3;

          const bounce = Math.sin((t * bounceFreq) + phase[i] * 2.2 + seed[i]*8.0) * bounceAmp;

          const tx = targets[i3+0];
          const ty = targets[i3+1] + bounce;
          const tz = targets[i3+2];

          const px = positions[i3+0];
          const py = positions[i3+1];
          const pz = positions[i3+2];

          const ax = (tx - px) * attractGain;
          const ay = (ty - py) * attractGain;
          const az = (tz - pz) * attractGain;

          velocities[i3+0] += ax * dt * 2.0;
          velocities[i3+1] += ay * dt * 2.0;
          velocities[i3+2] += az * dt * 2.0;
        }
      }

      function stepParticles(dt){
        const k = LERP_RETURN;
        const damp = Math.exp(-dt * 6.5);

        for (let i=0;i<PARTICLE_COUNT;i++){
          const i3 = i*3;

          const px = positions[i3+0];
          const py = positions[i3+1];
          const pz = positions[i3+2];

          const tx = targets[i3+0];
          const ty = targets[i3+1];
          const tz = targets[i3+2];

          velocities[i3+0] += (tx - px) * k;
          velocities[i3+1] += (ty - py) * k;
          velocities[i3+2] += (tz - pz) * k;

          velocities[i3+0] *= damp;
          velocities[i3+1] *= damp;
          velocities[i3+2] *= damp;

          positions[i3+0] = px + velocities[i3+0] * dt * 60;
          positions[i3+1] = py + velocities[i3+1] * dt * 60;
          positions[i3+2] = pz + velocities[i3+2] * dt * 60;
        }

        geometry.attributes.position.needsUpdate = true;
      }

      // =========================
      // Main Loop (FPS)
      // =========================
      let lastT = performance.now();
      let acc = 0, frames = 0, fps = 0;

      function animate(now){
        const dt = Math.min(0.033, (now - lastT) / 1000);
        lastT = now;

        // FPS HUD
        acc += dt; frames++;
        if (acc >= 0.25){
          fps = Math.round(frames / acc);
          frames = 0; acc = 0;
          $fps.textContent = String(fps);
        }
        $dt.textContent = String(Math.round(dt*1000));

        // Smooth index
        rightIndexSmoothed.lerp(rightIndex, 1 - Math.pow(1 - SMOOTH_LERP, dt * 60));
        rightVel.copy(rightIndexSmoothed).sub(rightPrev);
        rightPrev.copy(rightIndexSmoothed);

        // HUD statuses
        $lh.textContent = leftDetected ? (leftCatch ? "OPEN" : `${leftFingers}F`) : "--";
        $rh.textContent = rightDetected ? (rightOpen ? "OPEN" : "TRACK") : "--";

        // Presentation gestures: peace (2) next, fist (0) hide
        if (rightFingers === 2 && prevRightFingersForPres !== 2) {
          currentPresIndex = (currentPresIndex + 1) % presMeshes.length;
          updatePresentationObject(true, currentPresIndex);
        }
        if (rightFingers === 0) updatePresentationObject(false, currentPresIndex);
        prevRightFingersForPres = rightFingers;

        presMeshes[currentPresIndex].rotation.y += dt * 0.8;
        presMeshes[currentPresIndex].rotation.x += dt * 0.3;

        // Left command switching
        if (leftDetected && !leftCatch){
          applyLeftCommand(leftFingers);
        }

        // Modes
        const nebulaActive = rightDetected && rightOpen;
        const catchActive  = leftDetected && leftCatch;
        const ultimateActive = nebulaActive && catchActive;

        if (ultimateActive){
          if (mode !== MODE_ULT){
            mode = MODE_ULT;
            $mode.textContent = "ULT";
            $neb.textContent = "ON";
            $neb.className = "value warn";
            $cmd.textContent = "BASKETBALL";
            $cmd.className = "value warn";

            rightIndex.z = 0;
            setBasketballTargets(leftPalm);
          }
        } else if (nebulaActive){
          if (mode !== MODE_NEBULA){
            mode = MODE_NEBULA;
            $mode.textContent = "NEBULA";
            $neb.textContent = "ON";
            $neb.className = "value ok";
            $cmd.textContent = "NEBULA MODE";
            $cmd.className = "value ok";

            setNebulaTargets();
          }
        } else {
          if (mode !== MODE_MAIN){
            mode = MODE_MAIN;
            $mode.textContent = "MAIN";
            $neb.textContent = "OFF";
            $neb.className = "value";
            $cmd.textContent = leftCatch ? "CATCH" : slotLabel(currentSlot);
            $cmd.className = "value";
            applySlot(currentSlot);
          } else {
            $cmd.textContent = leftCatch ? "CATCH" : slotLabel(currentSlot);
            $cmd.className = "value";
          }
        }

        // Interactions
        if (rightDetected){
          if (mode === MODE_MAIN){
            applyPlanarRepulsion(dt);
            applyScatterImpulse(dt);
            rightIndex.z = 0;
          } else if (mode === MODE_NEBULA){
            rightIndex.z = 0;
            applyNebulaRipple(dt, now/1000);
          } else if (mode === MODE_ULT){
            rotateBasketballTargets(leftPalm, dt);
            applyUltimateBouncingAttraction(dt, now/1000);
          }
        }

        if (mode === MODE_ULT && !ultimateActive){
          mode = MODE_NEBULA;
        }

        stepParticles(dt);
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);

      // =========================
      // Tiny Safety: if no camera permission, still show animation.
      // =========================
    })();
  </script>
</body>
</html>
```
